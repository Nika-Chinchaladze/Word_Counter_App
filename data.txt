& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS: pachkovich
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES: pAchKovicH
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer.
& 1
OOP – Object Oriented Programming
OOP - is based on using objects and classes for programming. In classes, we bind data and functions together as one unit. We have variables inside class that are called - Attributes and functions that are called - methods. We can create object by using existing class and then access its attributes and methods, if we don't create object we can't access class elements from outside. When we have created object we should use dot-(.) after object name to access classes attributes and methods.

CLASS:
classes are logical entities that represents blueprints & plan - how objects can be created, and it contains attributes and methods. class is like a Factory to generate new objects. Example: maybe we want to track the description of cars - we don't need to create lists, dictionaries or any other data types to hold new car's characteristics - we can have Car class with several attributes and methods and based on this class we will be able to generate new cars as new objects.

ATTRIBUTES:
attributes can be defined as data variables inside __init__(self) method, something that we can provide from outside, if there are parameters of course but this method can have attributes without excepting data from outside.
There are 2 types of attributes:
    a) Class attributes - are created inside class and are shared by all objects that are created by using this class. If attribute will be changed by some object then, this attribute will be changed for all another objects as well.
    b) Instance attributes - are unique through each object/instance that is created by this class. If attribute will be changed from outside by some object then, this attribute won't be changed for all another objects.

PROPERTIES:
properties are unique attributes that contain getter, setter, deleter methods - __get__, __set__, __delete__.
To define properties we can use @property decorator or property() function.

OBJECTS:
objects are entities/instances that have identity, state and behavior.
for example => object created from Dog class.
a) identity - is represented as unique name of an object. (name of the dog)
b) state - is represented by attributes and properties of an object. (color, age of the dog)
c) behavior - is represented by methods. (eating, sleeping, running abilities of the dog)

THE SELF:
'self' represents the instance of the same class as 'this' in JavaScript objects. By using self we can access any attributes and methods of the class. self is always pointing to current object. self must be provided as the first parameter in constructor __init__() method and also in every method inside our class, but we don't need to provide any value for self parameter from outside when we call some method. self is not python keyword, its convention - it means that we can use any word instead of self, and it will have same functionality, but it is suggested to use self.

__INIT__():
constructor method that is used to define object's 'state' as soon as new object is created. It happens when we are providing values from outside - when we create object by using class. variables defined in this method are called as instance variables or objects.

INHERITANCE:
when child/derived class inherits attributes and methods from parent/base class. benefits:
a) re-usability - we don't need to write same code again and again.
b) we can add new features to class without modifying base class.
c) transitive nature - if B inherits from A and C inherits from B, it means that C inherits from A as well.

*) Single Inheritance - common inheritance B inherits from A.
*) Multiple Inheritance - when A inherits from multiple classes like from B, C, D.
*) Multi-level Inheritance - when C inherits from B which itself inherits from A class. (grandchild, child, parent)
*) Hierarchical Inheritance - when multiple child classes inherit from one parent class.

SUPER:
super() function returns object that represents parent class and only based on this we can access parent's attributes and methods. we don't need to use/remember parent class Name in child class to access its attributes and methods, but we must provide same parameters if they are needed in parent class.

PROTECTED MEMBERS:
attributes that can't be accessed from outside, but can be accessed within class itself or from child class and its subclasses. 'self._name'

PRIVATE MEMBERS:
attributes that won't be accessed from outside and also won't be available in child class, for this we must use following syntax: 'self.__name' double underscores in the beginning.

POLYMORPHISM - METHOD OVERRIDING:
when we have methods with the same names in parent and child classes. parameters and logic inside methods can be different, but names are same, so the main differences are: data types and quantity of arguments/parameters. why we use 'polymorphism'? - maybe method inherited from the parent class does not fit our requirements in the child class, so in these cases we use the same name in child class with functional modifications. 'Method Overriding' - reimplementing the method in child class with some modifications.

ENCAPSULATION:
wrap/bind data and methods (that work on this data) together within one unit. we can't access class variables and methods directly from outside that protects us from changing class data accidentally. we use private attributes during encapsulation, so we won't be able to change their values even we would create objects based on this class | private attributes won't be available from outside. for example: clients are not able to change their account's money balance while using bank application.

DATA ABSTRACTION:
when we want to hide code details from user / internal functionality / how code is implemented, we use data abstraction and create 'abstract classes' and 'interfaces'. At this time user just provide necessary arguments/parameter while using our class, but can't see the logic inside it. User knows 'what function does', but doesn't know 'how'.
*) Abstract Based Class - consists one or more abstract methods. abstract method doesn't have its implementation / logic, we just have 'pass' keyword inside abstract method in abstract class, but we use the same name for methods in child classes and there we have some functionality / logic for these methods. it is like 'Method Overriding'. For creating abstract class we are importing ABC and abstract method from abc module. we must define @abstractmethod decorator above method that we want to be abstract method, but actually it works without it as well. Abstract class can't be instantiated - we can't create object directly from Abstract Classes.

FOUR PRINCIPLE OF OOP - [Inheritance, Encapsulation, Polymorphism, Data Abstraction]


& 2
SOLID PRINCIPLES
SOLID:
solid means series of good practices that will make our code better and gives it better quality.
1.	Maintainability
2.	Testability
3.	Flexibility and Extensibility – flexible modifications
4.	Parallel Development – when team members are working on different features and they don’t need to work on the same feature at the same time.
5.	Loose Coupling – makes application easier and safer to make changes in one area of the system.


*) S - Single Responsibility Principle (SRP)
Class should be responsible for only one task, this is the best practice. Class should have responsibility over a single part of the functionality provided by software and that functionality should be entirely encapsulated by this class. Attributes and properties inside the class are mostly used by class methods, so it's better when they are related concepts and act like a one unit to solve one particular problem.
For example: I am a Painter, I am a Driver.
Bad Practice - when one class is responsible for multiple tasks and if we need to modify something we have to change entire class and these changes may affect another methods inside class which are responsible for another tasks, so it is bad practice. It is good to have separated classes for separated goals.

*) O - Open-Closed Principle (OCP)
class must be open to extension / add new features and closed to modifications / don't change anything existing. Based on this principle it is good practice to use Abstract Based Classes with abstract methods. Extend class functionality without changing existing behavior.
Good: I can Paint = Now I can Paint and Driving.
Bad: I can Paint = Now I can Driving.
It is better practice if we create new class when we want to add some more functionality.

*) L - Liskov's Substitution Principle (LSP)
1. Subclass can't have stricter conditions than they are defined in parent/base class - for example if base class checks a dictionary and raises error if it doesn't contain key - 'session_id', Subclass can't have extra condition that dictionary must contain - 'user_id' too.
2. Subclass can't have weaker conditions / some extra exceptions, than they are defined in parent/base class - for example if base class 'Member' says that member must pay, and we have Subclass 'Student' where we raise exception and say that students are allowed not to pay - THIS IS WRONG - AGAINST THIS PRINCIPLE. for the best practice Student can't be Subclass of Member, because Members must pay no matter of reason.
3. child class must be able to do everything that parent class can do and if child class is not able to do this it means that class is changed completely that violates this principle.

*) I - Interface Segregation Principle (ISP)
Interfaces are a set of methods an object must-have – interfaces describe what an item can do to fulfill a desired task. Users must be able to request correct methods of an object via its interface. In python, we use abstract base classes as interfaces, so based on this principle: 'interface should be as small as possible and in the best cases it should do only one task', it does not mean that they must have only one method, no they can have multiple methods, but they must serve one goal to complete one task. main idea is that: 'users shouldn't be forced to implement interfaces that they don't need to use'.
Bad Practice - for example if we have car and plane, we shouldn't inherit from Vehicle class which have fly() and move() abstract methods, because car doesn't need fly() and plane doesn't need move(), instead we should have separated abstract base classes with one method and from these classes we will inherit methods respectively.

*) D - Dependency Inversion Principle (DIP)
Abstraction – represents an interface that connects two classes.
High level module – class that executes the action with tool.
Low level module – tool that is needed to execute the action.
Details – how tool works.
it is the best practice when we are depending on abstract based classes / abstraction and not common classes. For example, if we are depended on common class and use its method in our class and then the name of used method will change - our code will crash because we use method that doesn't exist, so we must modify it. We need to find a way to avoid extra work, so it is the best practice if we use abstract based classes with abstract methods.
High level modules(class) should not be depended on low level modules(tools), they both should be depended on abstraction. The interaction between high level and low level modules should be implemented by using abstract classes.
Abstraction should not be depended on details, details should be depended on abstractions.

DEFINITION OF ABSTRACT CLASS:
Abstract method – abstract class method that has declaration but not implementation, we have just ‘pass’ keyword inside it. We can’t create objects from abstract classes – it can’t be instantiated and also we can’t create an object from class that inherits from abstract based class and hasn’t declared implementation for abstract method inside it.
When we want to provide same design pattern and common interface with different implementation, we normally use – abstract based classes. Because when implementation part is done by third-party, they will have some-kind of guideline while creating implementations for methods defined in abstract classes.

DEVELOPING GOOD APPLICATION:
	Choose correct Architecture
	Define Design Principles
	Choose correct Design Patterns


& 3
DRY, KISS, YAGNI
DRY, KISS, YAGNI – are product design principles, that define foundations for best practices that developers are using to create better products / better applications.
1.	KISS
Different abbreviations:
•	“Keep it simple, stupid”
•	“Keep it short and simple”
•	“Keep it simple and straightforward”
The main idea => The key aspect of creating successful product is simplicity.
Benefits:
•	Simple software structure makes manual and automated testing easier and effective.
•	Code complexity is extremely reduced, so it makes maintenance of product easier and the onboarding process for new developers is easier as well.

2.	YAGNI – “you aren’t gonna need it”
Based on this principle developers should only work on functionalities that are actually needed and desired. Developers mustn’t waste their time on creating some extra functionalities that might be useful in the future because finally maybe it turns out that it was not need or useful at all.
By using this principle developers are only concentrated on delivering current requirements and they don’t waste time on another features.

3.	DRY – “don’t repeat yourself”
Based on this principle developers have to reduce the repetitions of the same patterns in the code, they have to reduce creation of the same logic multiple times, instead they can create it ones and then use it in different places. This principle must be taken into consideration not only for codebases, but also in testing and documentation.
Following the DRY principle is extremely useful when we want to make some modifications in the logic because we can make modification only one place and the whole codebase will be affected, but if we don’t follow this principle than we will have to make modifications in different part of the code because same logic would be represented in multiple places and they all have to be modified.
Conclusion:
By using these principle we will get product with better user experience, the efficiency of developers will be increased because they will be able to create simple, maintainable and flexible codebases of products in a short period of time. Also they will be able to optimize the cost of creating not-necessary  features which decrease maintenance and time cost as well.


& 4
Microservice Architecture vs Monolith
Monolith
In monolithic applications we have whole code in one place - multiple components are united as one single-application - they are connected directly, so they have large codebases and are hard to be managed.
for example – if we have online shop application:
we have user authentication, product catalog, shopping cart, payment system, checkout, application business logic and one database in one space - directly connected.

DISADVANTAGES:
1.	 When one part/component of application needs to be updated than may another components also require to be re-written as well, so after changes the whole application must be recompiled and tested again, this process limits the speed of development process.
2.	For example, if part of the main project, like payment system is changed then the whole application must be re-created again as a new package and re-deployed and re-tested again.
3.	the whole application is written in one language by using concrete framework and during time and desired updates it's would be very hard and time consuming to turn from one language/framework into new one.
4.	When whole team works on the project, they must be very careful not to affect each other’s work, during complex projects it is very hard to coordinate between team members.
5.	Difficulty to use Dependency Versions in a flexible way - Using third party modules is also very sensitive, because developer must choose one that fits every component inside whole project, for example: if for payment systems the best choice is 1.8 version of module and for shopping cart the best is 1.9 version, we can’t use both – instead we have to choose one.
6.	The release process of monolith application is longer, because after every single change it needs to be re-built, re-tested and re-deployed again.

ADVANTAGES:
1.	monolithic way is well used for simple/lightweight applications, because at this simple level:
a.	throughput is better - how many units of information can process in a given moment, we don't communicate to other servers with APIs - everything we need is contained by our application so for smaller applications execution and data processing process is faster.
b.	deployment of simple/lightweight monolithic applications is simpler as well.

Microservices Architecture
By Using Microservices gives us ability to break down complex application into smaller and simple applications. During this process we must take into consideration that we must break application based on “business functionality” and not on “technical functionality”.
Microservices Architecture enables large team to build complex and scalable applications. Each microservice handles the dedicated / concrete function inside large scale application so they are responsible for one separated job, like: Shopping cart, Billing system, User profile, Notifications section and etc. Microservices are loosely coupled that means that they are completely independent from each other and they are designed, scaled, maintained and deployed independently, so because of simplicity and small codebases – microservices can easily be improved and re-deployed again and again - very often.
Well architected microservices provide strong information hiding by breaking down monolithic database into multiple logical components as separated databases and then each database is behind each separated microservices that is responsible for it. Despite of safety reasons for breaking down database – it is one of the main drawback of microservices, because relationships between database tables no longer exists – “foreign keys” for example are gone.

Communication between Microservices:
A.	Using API calls – each microservice has unique endpoint from where request can be received, so microservices can send and receive HTTP requests and communicate with each other in this way. This is example of Synchronous communication when one microservice send request to another and then waits the response.
B.	Asynchronous communication – by using “Message Broker”. At this time microservice sends message to – message broker and then message broker sends this message to final endpoint to another microservice.
C.	Service Mesh – like helper service that takes control over whole communication logic between microservices.
Based on the fact that Microservices are completely isolated from each other and communicating with above mentioned tools, they can be developed with different programming languages and frameworks. So the micro applications of the whole project can be developed in different tech stack, where developers won’t affect and won’t be affected by another developers who are working on another microservices.

DISADVANTAGES:
A.	Communication problems between microservices when one microservice is ready in production – sends requests but another microservice is down / not ready and this cause errors.
B.	When the whole application is not working properly it is hard to find where is the problem, because multiple microservices are deployed on multiple servers so the process is hard and time consuming.

Managing Application:
1.	Monorepo – Single Repository
a.	One repository for all microservices included into different folders. At this time code management is easier because everything is on one location, so they can be tracked together, tested together and released together.
b.	Microservices must be completely isolated from each other and this rule is broken while using – Monorepo.
c.	When application becomes complex and really big: cloning, fetching and pushing operations becomes slow.
d.	If the main branch will be broken then other microservices will be blocked as well.
2.	Polyrepo – Multiple Repositories
a.	During this time microservices are completely isolated, but as they are part of the one project we need to have some connection between them, so we Group Repositories on Gitlab for example.




& 5
Design Patterns
Design patterns are like blueprints - descriptions (typical solutions to commonly occurring problems in software design) that we can use to solve particular design problems into our code. They are not exact solutions, instead they are main concepts that we can follow and integrate into our code. There is a big difference between pattern and algorithm, algorithm defines concrete steps that must be followed to achieve concrete goal, but patterns aren’t. Pattern shows the final result and final features, but the exact implementation part is depended on developer.

BENEFITS:
Design patterns are already created, tried and tested solutions that lead us to highly readable code solutions, so instead of recreating new wheel again we can just use it or take into consideration and become developing process faster. Knowing design patterns is good even when you don’t need them in concrete example, because patterns show and teach us how to use Object-Oriented Design in practice correctly.

CLASSIFICATION:
There are three main group of design patterns, and they differ from each other by => complexity, level of detail and scale applicability:
1.	Creational Pattern – provide object creation mechanisms that increase flexibility and reusability of existing code.
2.	Structural Pattern – provide way, how to assemble / fit objects and classes into larger structures and at this time keep this structure flexible and efficient. Increase functionality of existing class.
3.	Behavioral Pattern – takes care on effective communication and efficient distribution of responsibilities between objects.

CRITICISM:
We shouldn’t always use patterns because maybe in some situations simple code would do the same job and patterns are not dogma, they exist to help us in different situations but there is always a space for smart improvisation.



& 6
Event-Driven Architecture
Software design pattern that helps to detect “events” and act on them in real time. This pattern replaces traditional “request/response” architecture, where service should wait for response and only then continue to another task – this is like synchronous communication. Event-Driven architecture is like asynchronous communication, where sender and receiver don’t have to wait each other to move onto next task. Service waits for some specific event and as soon as event happens – executes some specific action immediately.
Example N1: telephone call is example of “request/response” architecture, but text messaging is good example of “event-driven architecture”, when you send messages and you are not depended on answer – if someone sees / listens to your messages.
In event-driven architecture we move from data-centric model to event-centric model, where the main priority is to respond to the events as soon as they happen, because as old event gets as less valuable it becomes. In event-driven architecture, an event will likely trigger one or more actions or processes in response to its occurrence.
Example N2: Netflix upload new movie, at this time there will be some application that listens to this event and after happening it sends notifications to users about movie adding
Example N3:
Event
•	an unauthorized access attempt was denied.
•	request to reset a password.
Triggered actions
	account is locked and security personal is notified.
	an email was sent to reset password.

Components: = Producer, consumer, broker
Producer sends events to consumer. pachkovich PACHKOVICH,
